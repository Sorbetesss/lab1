---------------------------------------------------------------------------

by stof at 2022-07-06T07:35:45Z

Can you add a test to prevent regressions ?

---------------------------------------------------------------------------

by BrokenSourceCode at 2022-07-06T10:46:48Z

> Can you add a test to prevent regressions ?

@stof I think this should do the trick https://github.com/symfony/symfony/pull/46863/commits/d470523730ee7f7237fc586dd4c94f08010206b7.

---------------------------------------------------------------------------

by calebsolano at 2022-07-06T17:02:53Z

> I hope this solution will suit you, I couldn't think of an easier one.

Maybe I still don't quite understand the root of the issue, but wouldn't it be easier to cache the boundary instead the body?

---------------------------------------------------------------------------

by BrokenSourceCode at 2022-07-06T17:33:33Z

> Maybe I still don't quite understand the root of the issue, but wouldn't it be easier to cache the boundary instead the body?

@calebsolano This is what I wanted to do first instead of the current commits:

Before
```php
    private function getBoundary(): string
    {
        if (null === $this->boundary) {
            $this->boundary = strtr(base64_encode(random_bytes(6)), '+/', '-_');
        }

        return $this->boundary;
    }
```

After
```php
    private function getBoundary(): string
    {
        static $boundary = null;
        if (null === $boundary) {
            $boundary = strtr(base64_encode(random_bytes(6)), '+/', '-_');
        }

        return $boundary;
    }
```

But it seems to me that the boundary must be unique for each e-mail, if I understand the rules correctly. It's right that this solution would be simpler, but I don't really know if having the same boundary for multiple emails can cause real problems. Maybe do you have any information about this?

And you, @stof @fabpot, do you have any views on this?

---------

EDIT: https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html

I don't see any rules for the unicity for each email. So maybe we should use this simple solution, by increasing the number of generated bytes from 6 to 12 (base64 encoded this is from 8 to 16).

---------------------------------------------------------------------------

by calebsolano at 2022-07-06T18:29:47Z

I now see why the body caching seems to be the best solution.

Based on some of the comments above about "The two bodies must not reference the same object.", shouldn't
```
if (null !== $this->cachedBody) {
    return $this->cachedBody;
}
```

be

```
if (null !== $this->cachedBody) {
    return clone $this->cachedBody;
}
```

Also, couldn't the same functionality of the "cachedBody" be implemented by calling setBody instead? (Although that would require a call to setBody(null) in all the email modification functions, which may have side effect?)

---------------------------------------------------------------------------

by BrokenSourceCode at 2022-07-06T18:41:12Z

> I now see why the body caching seems to be the best solution.
>
> Based on some of the comments above about "The two bodies must not reference the same object.", shouldn't
>
> ```
> if (null !== $this->cachedBody) {
>     return $this->cachedBody;
> }
> ```
>
> be
>
> ```
> if (null !== $this->cachedBody) {
>     return clone $this->cachedBody;
> }
> ```

No, the comment you are talking about is just intended to comment the test assertion. We need to keep the same object to resolve the issue.

But I wonder if the boundary caching solution (with a static property) is not easier. Like that: https://github.com/symfony/symfony/pull/46863#issuecomment-1176496795

> Also, couldn't the same functionality of the "cachedBody" be implemented by calling setBody instead? (Although that would require a call to setBody(null) in all the email modification functions, which may have side effect?)

That's why using a property `cachedBody` is easier than a method `setBody()`, because we don't need to changes all the functions everywhere
