---------------------------------------------------------------------------

by unkind at 2017-10-19T17:56:28Z

I didn't fix all the tests yet (is there any script to update all autogenerated DI-fixtures?), need feedback. ping @nicolas-grekas

UPD: target branch is incorrect. Anyway, any chance to merge it in 3.4? If so, I'll reopen PR.

---------------------------------------------------------------------------

by unkind at 2017-10-19T22:04:48Z

> I think I'm ðŸ‘Ž: this will introduce a non trivial amount of complexity (it's broken already), when the current way just works (just give that decorator a name.)

What about just anonymous services without decorators?

---------------------------------------------------------------------------

by nicolas-grekas at 2017-10-19T22:18:01Z

> What about just anonymous services without decorators?

I would do it without the "anonymous" helper: `->set(null, Fqcn::class)`

---------------------------------------------------------------------------

by unkind at 2017-10-19T22:31:24Z

> I would do it without the "anonymous" helper

Well, a lot (probably, most) of my services are anonymous: listeners, command handlers, API controllers, console commands, cache/monitoring/logging decorators. I can use `set(SendEmailForRegisteredUserListener::class, ...)` for most of them, but they include namespace and service name becomes very long. On other hand, typing `set(null, ...)` again and again doesn't make me happy as well.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-10-19T22:50:16Z

My fear is that ppl will get confused when reading
`->set(Foo::class)`
vs
`->anonymous(Foo::class)`
the difference is not obvious if you're not used to anonymous services (how many of us are, of many new comers...)
`->set(null, Foo::class)` on the contrary is "more" different than `->set(Foo::class)`

And I'm also fearing that writing actually might become more confusing: "anonymous" would become a new item on the autocompletion list, which ppl might have a hard time figure out what it means (because it's not that common) - and even scarier: ppl doing the mistake of selecting the wrong set/anonymous choice might have an even harder time figuring out their mistake.

---------------------------------------------------------------------------

by unkind at 2017-10-19T23:10:25Z

> the difference is not obvious if you're not used to anonymous services
> And I'm also fearing that writing actually might become more confusing

Let them learn the difference. They won't hurt themselves, it's not a gun.

> (how many of us are, of many new comers...)

I think most of us have such services in our codebases, we probably just don't realize it. It's yet another reason to make it explicit in my opinion.

---------------------------------------------------------------------------

by unkind at 2017-10-20T21:05:29Z

I've removed decorators, tests are OK except some unrelated ones.

Let's focus on the `anonymous()` helper. Do you really want to remove it? I'd like to see it as explicit way to register a service, I really don't like nullables, it's almost always better to introduce new straightforward method. I also really doubt it's sort of "forbidden knowledge" that may bring any problems to people. They'd rather discover something new for themselves.

---------------------------------------------------------------------------

by unkind at 2017-10-20T21:28:49Z

Offtopic:

> just give that decorator a name

This annoys in the same way as requirement to specify name for "anonymous" services: I don't need it. Considering we have name convention for service names like `game.infrastructure.players_qs_memcache_decorator.inner`, it becomes a problem. We also have sometimes 3-4 similar services with decorators, so I copy-paste definitions and trying to find the difference in names which I don't even need, ugh.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-11-26T19:46:25Z

I'm still really unsold on the topic, if anything, `->set(null, Foo::class)` should be the way to IMHO.
Services don't *have* to be anonymous. Giving them a name is fine (esp. when the name is automatically set as is now.)

---------------------------------------------------------------------------

by unkind at 2017-11-26T20:05:35Z

@nicolas-grekas it looks like a [straw man](https://en.wikipedia.org/wiki/Straw_man) for me: I didn't say that services _have_ to be anonymous. Just many of them _could_ be. Giving name is fine, but sometimes is totally pointless like rituals.

> `->set(null, Foo::class)`

Giving a name for this construction is fine, isn't it? `->set(null, Foo::class)` is WTF syntax and it's harder to google it.

The whole discussion is about explicit vs implicit syntax for the same concept. I don't understand your point why this kind of syntax should be implicit.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-11-26T20:16:06Z

Oh! :)
*could be* would need a reason. When doing `->set(Foo::class)` is actually fine, I really don't see benefit of doing `->anonymous(Foo::class)`. The first providing a name is a side effect that benefits everyone when needing a name, and doesn't hurt anyone when a name is actually not needed. That's my reasoning. Just let SF give a name for you, and ignore it if you don't need it.
The only case where the name is actually boilerplate if when you need several services implemented by the same class. Which is a case where you have to type some configuration anyway, and doing `->set(null, Foo::class)` would just work and not look like impossible boilerplate IMHO.

---------------------------------------------------------------------------

by unkind at 2017-11-26T21:29:42Z

@nicolas-grekas while `->set(Foo::class)` works for many cases, I think this is just a coincidence. You presume that service is a singleton, but it isn't the same as anonymous service: it can be referenced directly (but you probably want explicitly say that listener shouldn't be injected directly), it actually has a name. Moreover, you have to keep in the mind every time whether a service is a singleton or not to choose between `set(Foo:class)` and `set(null, Foo:class)`.

By doing `->anonymous(Foo::class)` you explicitly say that service shouldn't be referenced directly and you don't care how much services of the class exist. It is easier, more straightforward and more google-friendly.

> I really don't see benefit of doing

Benefit is clarity of intent. Let's say we want to make a coffee machine for several types of coffee including latte. You say that "you can make a latte by pressing buttons 'espresso', 'steamed milk' and 'milk foam' sequentially, but if X is true, you have to press them at the same time". I propose to add "make a latte" button, this is perfectly fine keyword for coffee machine bounded context.

Another minor technical benefit is a size of name.

> The first providing a name is a side effect

Exactly, it is a side-effect and not primary function. In other words, you reach the pseudo-anonymous effect _coincidentally_ in specific set of cases, and you have to use another syntax for the same effect in other cases. It is complicated.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-11-26T22:19:17Z

Ok, thanks for the arguments. I'll let others contribute to the discussion, as my personal pov doesn't specifically matter (and I might just be missing the point...)

---------------------------------------------------------------------------

by unkind at 2017-12-04T12:29:02Z

In other words, introducing new keyword is about ubiquitous language. "Service without explicit name (null)" is worse than "anonymous". It is less descriptive and people don't talk like that in discussions. People are not robots. `null` is technical detail, implementation. We don't "set name of User", we _rename_ him, we don't "set status to 'Blocked' and set 'banned_at' to the current timestamp", we _block violators_.

However, if majority of deciders think other way, I'm ready to make `->set(null, Foo::class)`.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-08T19:45:11Z

ping @symfony/deciders I gave my pov, yours welcome now :)

---------------------------------------------------------------------------

by Tobion at 2017-12-08T20:31:35Z

`->anonymous(Foo::class)` is much better than `->set(null, Foo::class)`

---------------------------------------------------------------------------

by weaverryan at 2017-12-09T18:16:46Z

Haha, well, it's one of those things that is tough to agree on.

I think the exact opposite. I think that `->set(null, Foo::class)` is better than `->anonymous(Foo::class)`.

But there's more to it. I don't *love* `->set(null, Foo::class)`, but when we add a new function (e.g. `anonymous`), it introduces another auto-complete option, and so makes the 99% use-cases just a *little* bit less findable. That's a real cost, especially when the purpose of the PHP format is to help people naturally find their way.

That's why I prefer `->set(null, Foo::class)`: it's less discoverable (that's a +) and if you *do* find it, it's more descriptive. I don't know what an anonymous service is. But I can clearly see from this code that I'm creating a service without an `id`. No need to introduce new terminology.

tl;dr; +1 for `->set(null, Foo::class)`

---------------------------------------------------------------------------

by unkind at 2017-12-09T20:06:33Z

> but when we add a new function (e.g. anonymous), it introduces another auto-complete option, and so makes the 99% use-cases just a little bit less findable

>  I prefer ->set(null, Foo::class): it's less discoverable (that's a +)

`anonymous(Foo::class)` makes definition "less findable" and `->set(null, Foo:class)` is "less discoverable"? I'm confused. ðŸ˜•

By the way, how do you search? Regex? I usually search by usages of the `Foo::class`.

What do you think about `->setNameless(Foo::class)`?

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-10T11:10:47Z

Thanks @weaverryan, we're on par.

@unkind `->setNameless(Foo:class)` is longer than `->set(null, Foo:class)` (if that matters) and has the same drawbacks as "anonymous": (from Ryan): "it introduces another auto-complete option, and so makes the 99% use-cases just a little bit less findable. That's a real cost"

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-10T12:01:42Z

Note that decisions for what we think should make it into core don't bind you to not have autocompletion:
It should be quite easy to define your own DSL, by creating a different set of configurator classes, and type-hinting for them in the closure.

---------------------------------------------------------------------------

by Tobion at 2017-12-10T12:44:41Z

Changing the allowed parameters of `set` will confuse everybody. How do you want to explain the difference between `set('...', null)` and `set(null, '...')` when people start using it for the first time? It's not clear at all.
And since both paramters can be null, you also need to validate `set(null, null)`. Really nice dev exp...

---------------------------------------------------------------------------

by unkind at 2017-12-10T13:49:56Z

> How do you want to explain the difference between `set('...', null)` and `set(null, '...')`

"The first one is a _singleton_ service, the second one is an _anonymous_ service". Oh, wait...

---------------------------------------------------------------------------

by chalasr at 2017-12-10T14:07:29Z

I would prefer a dedicated method first because it seems more explicit than a nullable arg, which is quite important to me given it's about a fluent api, as we don't want it to have/expose the same "flaws" as the low level api, nullable/boolean based behaviors are meaningless, not obvious for readers as well as for writers.
It feels also weird to me to call `set()` for something that can't be `get()` nor `ref()` afterwards, I mean that setting something implies that it can be retrieved later, that is not the case here.
+1 for `anonymous()` or whatever that reflects the fact that the service is not meant to be identifiable/retrievable outside of the context where it has been created (thought about `new()`...).

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-10T15:23:13Z

So, I'm going to be a bit more explicit: I strongly think making anonymous services a first class thing would be a bad decision.

We actively deprecated anonymous services in XML because they were confusing.

The same applies here.

:-1: on my side.

---------------------------------------------------------------------------

by unkind at 2017-12-10T18:09:44Z

> We actively deprecated anonymous services in XML because they were confusing.

I think this is a different concept, those services better be called _inlined_, for example. By giving a right name, we can understand each other a little bit better. Right name by itself cannot be a reason of confusion. Probably, the whole idea of inlined services was confusing, not a _name_?

The same applies here: if the whole idea of anonymous services is bad, wouldn't be better to reject it completely rather than hide functionality?

---------------------------------------------------------------------------

by javiereguiluz at 2017-12-10T18:15:18Z

I don't know if anonymous services should be removed or not ... but I agree they should be removed from XML and YAML config files. They are super confusing because it's like trying to develop PHP code using XML or YAML.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-10T18:18:07Z

I was really talking about anonymous services: ones at the root of the service list, without any "id" attribute. Inlined ones are those nested in definitions, as eg argument. They also don't have id, but they're not deprecated.

Anonymous services are not possible neither in Yaml nor in XML anymore. But inline are in both (and in PHP DSL.)

---------------------------------------------------------------------------

by unkind at 2017-12-10T18:51:31Z

> I was really talking about anonymous services: ones at the root of the service list, without any "id" attribute.

Ah, I didn't know about it (#21970). Why they were confusing, because of syntax? As for me, XML and YAML are confusing formats by themselves. ðŸ™‚ UPD: wait, it looks like inlined service too:

```yml
services:
    _instanceof:
        FooInterface:
            arguments:
                - !service
                    class: Bar
                    autowire: true
```

> Defaults and instanceof conditionals aren't applied on anonymous services, as in xml too.

Why?

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-10T21:20:22Z

Yep, the title of the PR there talks about anonymous services, but that's what we should call inlined ones.

I was more thinking about #22903.

> Defaults and instanceof conditionals aren't applied on anonymous services

No definitive answer. When we worked on it, it added a lot of mental overhead, and was technically not obvious either, with many undefined edge cases (eg tags: what's their meaning on an inlined service, etc. ?)
So we applied the "simplest is best" principle and all problems were solved. It prevents no one from doing anything, just makes things easier to reason about.

---------------------------------------------------------------------------

by unkind at 2017-12-10T21:48:43Z

> I was more thinking about #22903.

As I can see, the problem was exactly with implicit syntax: they confused `<service class="...">` and `<service id="...">`. And now we fall into the same trap with `->set(null, '...')` and `->set('...', null)`. It's not foolproof.

For XML, for example, I'd prefer `<anonymous-service class="Acme\Foo">`. `id` doesn't make sense for `<anonymous-service>`, for instance. Yeah, it is new terminology, but it helps to think more about what you are doing.

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-11T09:02:37Z

> it is new terminology

And for this reason, I'm :-1:
There are enough concepts to grasp already.
All service must have a name in the end (even these anonymous one end up having one in the end - randomly generated)
Asking ppl to always add a name is making everything easier to understand, explain, reference, put in error messages, etc.

---------------------------------------------------------------------------

by unkind at 2017-12-18T02:28:34Z

> It should be quite easy to define your own DSL, by creating a different set of configurator classes, and type-hinting for them in the closure.

What do you think of decorators for `ContainerConfigurator`?

```diff
@@ -23,6 +25,16 @@ use Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigura
  */
 class PhpFileLoader extends FileLoader
 {
+    private $configuratorDecorator;
+
+    public static function withConfiguratorDecorator(ContainerBuilder $container, FileLocatorInterface $locator, callable $configuratorDecorator): PhpFileLoader
+    {
+        $loader = new self($container, $locator);
+        $loader->configuratorDecorator = $configuratorDecorator;
+
+        return $loader;
+    }
+
     /**
      * {@inheritdoc}
      */
@@ -44,7 +56,13 @@ class PhpFileLoader extends FileLoader
         $callback = $load($path);

         if ($callback instanceof \Closure) {
-            $callback(new ContainerConfigurator($this->container, $this, $this->instanceof, $path, $resource), $this->container, $this);
+            $configurator = new ContainerConfigurator($this->container, $this, $this->instanceof, $path, $resource);
+
+            if ($this->configuratorDecorator) {
+                $configurator = call_user_func($this->configuratorDecorator, $configurator);
+            }
+
+            $callback($configurator, $this->container, $this);
         }
```

---------------------------------------------------------------------------

by ro0NL at 2017-12-28T18:25:11Z

`set(null, Foo::class)` doesnt work in 4.0 due `string $id` type :) which is also the phpdoc in 3.4, this is actually consistent with the current loaders right.

Anyway, just walked into this trying to register a event listener twice. Now in a codebase full of `set(Fqcn::class)` the `set(null, Fqcn::class)` (if it worked) looks a bit odd... but im really thinking of a good ID value now :thinking: (the "naming is hard" issue also counts a bit IMHO).

---------------------------------------------------------------------------

by unkind at 2017-12-28T19:01:20Z

> naming is hard

Especially when you don't need a name (anonymous/lambda functions is a very close example).

---------------------------------------------------------------------------

by nicolas-grekas at 2017-12-29T10:35:43Z

> set(null, Foo::class) doesnt work in 4.0 due string $id type

which is not an issue since the method is final, so can be changed without any BC break

---------------------------------------------------------------------------

by ro0NL at 2017-12-29T10:46:40Z

Hm looking at failing tests locally

```
+    :\n
+        class: App\BarService\n
+        public: true\n
```

that's bad right? :)

---------------------------------------------------------------------------

by unkind at 2017-12-29T11:11:10Z

@ro0NL if you mean my branch, it's possible if you merged with 3.4/master because `ContainerBuilderTest` was changed (GitHub shows the conflict). I could resolve it, but I don't understand the state of PR.

Do I understand correctly that in order to merge it I have to replace `->anonymous()` with `->set(null, ...)`?

---------------------------------------------------------------------------

by ro0NL at 2017-12-29T11:13:11Z

right. I tested on 3.4 :) i thought it worked today already. If we can settle with `set(null, Fqcn::class)` im fine :+1:

---------------------------------------------------------------------------

by unkind at 2018-01-04T00:41:05Z

@nicolas-grekas can you change base branch on master?

---------------------------------------------------------------------------

by curry684 at 2018-01-04T01:19:24Z

You can do it yourself with the `edit` button at the top of the issue.

---------------------------------------------------------------------------

by unkind at 2018-01-04T01:32:30Z

@curry684 thanks, didn't know it.

---------------------------------------------------------------------------

by unkind at 2018-01-22T20:24:31Z

OK, looks good.

---------------------------------------------------------------------------

by fabpot at 2018-01-23T06:32:10Z

Cannot be merged as tests are broken.

---------------------------------------------------------------------------

by nicolas-grekas at 2018-01-23T06:59:20Z

Tests fixed, should be green in a few minutes.
