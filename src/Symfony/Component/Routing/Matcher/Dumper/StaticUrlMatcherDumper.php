<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Routing\Matcher\Dumper;

use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
use Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface;

/**
 * StaticUrlMatcherDumper creates a PHP array to be used with StaticUrlMatcher.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Tobias Schultze <http://tobion.de>
 * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
 * @author Nicolas Grekas <p@tchwork.com>
 */
class StaticUrlMatcherDumper extends MatcherDumper
{
    private $expressionLanguage;
    private $expressions = array();
    private $expressionsIndex = array();

    /**
     * @var ExpressionFunctionProviderInterface[]
     */
    private $expressionLanguageProviders = array();

    /**
     * {@inheritdoc}
     */
    public function dump(array $options = array())
    {
        list($routes, $expressions) = $this->compileRoutes($this->getRoutes());

        return <<<EOF
<?php

// This file has been auto-generated by the Symfony Routing Component.

return array(
    {$this->exportRoutes($routes)},
    {$this->exportExpressions($expressions)},
);

EOF;
    }

    public function addExpressionLanguageProvider(ExpressionFunctionProviderInterface $provider)
    {
        $this->expressionLanguageProviders[] = $provider;
    }

    private function compileRoutes(RouteCollection $routes): array
    {
        try {
            $groups = $this->groupRoutesByHostRegex($routes);
            $dumpedRoutes = array();

            foreach ($groups as $collection) {
                $tree = $this->buildStaticPrefixCollection($collection);
                if (!$tree->getItems()) {
                    continue;
                }
                $dumpedRoutes[] = array(
                    $collection->getAttribute('host_regex'),
                    $this->compileStaticPrefixRoutes($tree),
                );
            }

            return array($dumpedRoutes, $this->expressions);
        } finally {
            $this->expressions = $this->expressionsIndex = array();
        }
    }

    private function buildStaticPrefixCollection(DumperCollection $collection): StaticPrefixCollection
    {
        $prefixCollection = new StaticPrefixCollection();

        foreach ($collection as $dumperRoute) {
            $prefix = $dumperRoute->getRoute()->compile()->getStaticPrefix();
            $prefixCollection->addRoute($prefix, $dumperRoute);
        }

        $prefixCollection->optimizeGroups();

        return $prefixCollection;
    }

    private function compileStaticPrefixRoutes(StaticPrefixCollection $collection): array
    {
        $prefix = $collection->getPrefix();
        $dumpedRoutes = array(
            !empty($prefix) && '/' !== $prefix ? $prefix : null,
        );

        foreach ($collection->getItems() as $route) {
            if (!$route instanceof StaticPrefixCollection) {
                $dumpedRoutes[] = $this->compileRoute($route[1]->getRoute(), $route[1]->getName(), $prefix);
            } elseif ($route->getItems()) {
                $dumpedRoutes[] = $this->compileStaticPrefixRoutes($route);
            }
        }

        return $dumpedRoutes;
    }

    /**
     * Compiles a single Route to PHP code used to match it against the path info.
     */
    private function compileRoute(Route $route, string $name, string $parentPrefix = null): array
    {
        $dumpedRoute = array();
        $compiledRoute = $route->compile();
        $conditions = array();
        $methods = array_values($route->getMethods());
        $schemes = array_values($route->getSchemes());

        $supportsTrailingSlash = !$methods || in_array('HEAD', $methods) || in_array('GET', $methods);
        $regex = $compiledRoute->getRegex();

        if (!count($compiledRoute->getPathVariables()) && false !== preg_match('#^(.)\^(?P<url>.*?)\$\1#'.('u' === $regex[-1] ? 'u' : ''), $regex, $m)) {
            if ($supportsTrailingSlash && '/' === $m['url'][-1]) {
                $conditions[] = 'trim';
                $conditions[] = rtrim(str_replace('\\', '', $m['url']), '/');
            } else {
                $conditions[] = 'path';
                $conditions[] = str_replace('\\', '', $m['url']);
            }
        } else {
            if ($start = $compiledRoute->getStaticPrefix() && $compiledRoute->getStaticPrefix() !== $parentPrefix) {
                $conditions[] = 'start';
            } else {
                $conditions[] = 'match';
            }

            $conditions[] = ($supportsTrailingSlash && $pos = strpos($regex, '/$')) ? substr_replace($regex, '(?P<>/?)$', $pos, 2) : $regex;

            if ($start) {
                $conditions[] = $compiledRoute->getStaticPrefix();
            }
        }

        if ($route->getCondition()) {
            $expression = $this->getExpressionLanguage()->compile($route->getCondition(), array('context', 'request'));

            if (isset($this->expressionsIndex[$expression])) {
                $expr = $this->expressionsIndex[$expression];
            } else {
                $this->expressionsIndex[$expression] = $expr = count($this->expressionsIndex);
                $this->expressions[] = $expression;
            }
        } else {
            $expr = null;
        }

        $dumpedRoute[] = $conditions;
        $dumpedRoute[] = $expr;
        $dumpedRoute[] = array_combine($methods, $methods) ?: null;
        $dumpedRoute[] = array_combine($schemes, $schemes) ?: null;
        $dumpedRoute[] = array_replace($route->getDefaults(), array('_route' => $name));

        return $dumpedRoute;
    }

    /**
     * Groups consecutive routes having the same host regex.
     *
     * The result is a collection of collections of routes having the same host regex.
     */
    private function groupRoutesByHostRegex(RouteCollection $routes): DumperCollection
    {
        $groups = new DumperCollection();
        $currentGroup = new DumperCollection();
        $currentGroup->setAttribute('host_regex', null);
        $groups->add($currentGroup);

        foreach ($routes as $name => $route) {
            $hostRegex = $route->compile()->getHostRegex();
            if ($currentGroup->getAttribute('host_regex') !== $hostRegex) {
                $currentGroup = new DumperCollection();
                $currentGroup->setAttribute('host_regex', $hostRegex);
                $groups->add($currentGroup);
            }
            $currentGroup->add(new DumperRoute($name, $route));
        }

        return $groups;
    }

    private function getExpressionLanguage(): ExpressionLanguage
    {
        if (null === $this->expressionLanguage) {
            if (!class_exists(ExpressionLanguage::class)) {
                throw new \RuntimeException('Unable to use expressions as the Symfony ExpressionLanguage component is not installed.');
            }
            $this->expressionLanguage = new ExpressionLanguage(null, $this->expressionLanguageProviders);
        }

        return $this->expressionLanguage;
    }

    private function exportRoutes(array $routes): string
    {
        if (!$routes) {
            return 'array()';
        }

        $code = '';
        foreach ($routes as list($hostRegex, $routeCollection)) {
            $code .= <<<EOF
        array(
            {$this->export($hostRegex)},
            {$this->exportCollection($routeCollection)},
        ),

EOF;
        }

        return "array(\n$code    )";
    }

    private function exportCollection(array $routes, int $indent = 1): string
    {
        $pad = '            '.str_repeat('    ', $indent);
        $code = "array(\n$pad{$this->export($routes[0])},\n";
        for ($i = 1; $i < \count($routes); ++$i) {
            if (!\is_array($routes[$i][0])) {
                $code .= $pad.$this->exportCollection($routes[$i], 1 + $indent).",\n";
            } else {
                $code .= $pad.$this->export($routes[$i]).",\n";
            }
        }

        return $code.substr_replace($pad, ')', -4);
    }

    private function exportExpressions(array $expressions): string
    {
        if (!$expressions) {
            return 'array()';
        }

        $code = '';
        foreach ($expressions as $expression) {
            $code .= "        function (\$context, \$request) { return $expression; },\n";
        }

        return "array(\n$code    )";
    }

    /**
     * @internal
     */
    public static function export($value): string
    {
        if (null === $value) {
            return 'null';
        }
        if (!\is_array($value)) {
            return var_export($value, true);
        }
        if (!$value) {
            return 'array()';
        }

        $i = 0;
        $export = 'array(';

        foreach ($value as $k => $v) {
            if ($i === $k) {
                ++$i;
            } else {
                $export .= var_export($k, true).' => ';

                if (\is_int($k) && $i < $k) {
                    $i = 1 + $k;
                }
            }

            $export .= self::export($v).', ';
        }

        return substr_replace($export, ')', -2);
    }
}
